\documentclass{article}

\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{alphabeta} % For Greek characters
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float} % For [H] option in figures/tables
\usepackage[ruled,vlined]{algorithm2e}

\title{Εργασία 2}
\author{Βογιατζής Χαρίσιος \\ ΑΕΜ:9192}
\date{\today}

\lstset{
  language=C,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  stepnumber=1,
  numbersep=5pt,
  backgroundcolor=\color{white},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=true,
  title=\lstname,
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{purple}
}

\begin{document}

\maketitle

\begin{center}
\href{https://github.com/charisvt/micro-lab2}{Github Source Code (Lab 2)}
\end{center}

\section{Εισαγωγή}

Ο στόχος της δεύτερης εργαστηριακής άσκησης είναι η ανάπτυξη ενός συστήματος ανάλυσης ψηφίων για μιρκο-ελεγκτές ARM. Το σύστημα λαμβάνει έναν αριθμό μέσω σειριακής επικοινωνίας (UART), τον αναλύει ψηφίο προς ψηφίο, και παρέχει οπτική ανάδραση μέσω ενός LED και UART logging. Η λειτουργικότητα επεκτείνεται με την ανίχνευση συνεχούς λειτουργίας και τη δυνατότητα παγώματος/επαναφοράς της κατάστασης του LED μέσω ενός κουμπιού, χωρίς να διακόπτεται η κύρια λογική ανάλυσης ή η σειριακή επικοινωνία.

Οι κύριες λειτουργίες περιλαμβάνουν:
\begin{itemize}
    \item Λήψη αριθμητικής εισόδου μέσω UART.
    \item Διαδοχική ανάλυση κάθε ψηφίου του αριθμού με χρονικό διάστημα 0.5 δευτερολέπτων ανάμεσα στα ψηφία.
    \item Διαφορετική οπτική ένδειξη LED για ζυγά και μονά ψηφία:
    \begin{itemize}
        \item Μονά ψηφία: Εναλλαγή της κατάστασης του LED (ON/OFF).
        \item Ζυγά ψηφία: Αναβόσβημα του LED (200ms ON, 200ms OFF) για όσο διαρκεί η ανάλυση του ψηφίου.
    \end{itemize}
    \item Υποστήριξη "συνεχούς λειτουργίας" (continuous mode) εάν η είσοδος τελειώνει με τον χαρακτήρα '-'.
    \item Διαχείριση πατήματος κουμπιού μέσω εξωτερικής διακοπής για το πάγωμα (lock) και την επαναφορά (unlock) της φυσικής κατάστασης του LED, ενώ η λογική κατάσταση και η σειριακή καταγραφή συνεχίζονται κανονικά.
    \item Συνεχής καταγραφή (logging) των ενεργειών και των καταστάσεων του συστήματος μέσω UART.
\end{itemize}

\section{Υλοποίηση}

\subsection{Διακοπές (Interrupts)}
Ο χρονοδιακόπτης SysTick χρησιμοποιείται για τη διαχείριση του χρονισμού των βασικών λειτουργιών. Συγκεκριμένα, ρυθμίζεται να παράγει διακοπές κάθε 1ms. Αυτές οι διακοπές αξιοποιούνται για την υλοποίηση δύο χρονιστών λογισμικού: ενός για την ανάλυση κάθε ψηφίου της ακολουθίας εισόδου (με περίοδο 500ms) και ενός για το αναβόσβημα του LED όταν ανιχνεύεται ζυγό ψηφίο (με κύκλο 200ms ON / 200ms OFF).

Η διακοπή λήψης UART (UART RX) ενεργοποιείται κάθε φορά που λαμβάνεται ένας νέος χαρακτήρας μέσω της σειριακής θύρας. Οι λαμβανόμενοι χαρακτήρες αποθηκεύονται σε μια προσωρινή ουρά (buffer) για επεξεργασία από την κύρια λογική του προγράμματος. Αυτός ο μηχανισμός επιτρέπει την ασύγχρονη λήψη της ακολουθίας ψηφίων από τον χρήστη.

Η εξωτερική διακοπή (EXTI) που συνδέεται με το κουμπί χρήστη χρησιμοποιείται για την εναλλαγή της κατάστασης παγώματος (freeze/unfreeze) του LED. Όταν το κουμπί πατηθεί, η αντίστοιχη ISR (Interrupt Service Routine) αλλάζει την κατάσταση μιας σημαίας (flag) που υποδεικνύει αν το LED πρέπει να παραμένει στη φυσική του κατάσταση ή να ακολουθεί τις εντολές της λογικής ανάλυσης ψηφίων. Η διακοπή αυτή έχει σχεδιαστεί ώστε να μην επηρεάζει την τρέχουσα ανάλυση ψηφίων, επιτρέποντας μόνο την οπτική παύση της ανάδρασης του LED.

\subsection{Βασικές Δομές Δεδομένων}
Για την οργάνωση της λογικής του συστήματος, χρησιμοποιούνται ορισμένες βασικές δομές δεδομένων και μεταβλητές κατάστασης:

\begin{itemize}
    \item \textbf{AppState}: Μια απαρίθμηση (enum) που ορίζει τις κύριες καταστάσεις λειτουργίας του συστήματος. Οι καταστάσεις αυτές περιλαμβάνουν τυπικά:
    \begin{itemize}
        \item \texttt{APP\_STATE\_INIT}: Αρχική κατάσταση κατά την εκκίνηση του συστήματος, όπου πραγματοποιούνται οι απαραίτητες αρχικοποιήσεις περιφερειακών και μεταβλητών.
        \item \texttt{APP\_STATE\_IDLE}: Το σύστημα βρίσκεται σε αδράνεια, αναμένοντας νέα είσοδο (αριθμό) από τον χρήστη μέσω UART.
        \item \texttt{APP\_STATE\_RECEIVING\_INPUT}: Το σύστημα βρίσκεται σε διαδικασία λήψης χαρακτήρων από τη σειριακή θύρα UART για τη σύνθεση του αριθμού προς ανάλυση.
        \item \texttt{APP\_STATE\_START\_ANALYSIS}: Μετά την επιτυχή λήψη ενός αριθμού, το σύστημα εισέρχεται σε αυτή την κατάσταση για να προετοιμαστεί για την έναρξη της ανάλυσης των ψηφίων του.
        \item \texttt{APP\_STATE\_ANALYZING\_DIGIT}: Το σύστημα αναλύει ένα-ένα τα ψηφία του ληφθέντος αριθμού, εκτελώντας την αντίστοιχη λογική για το LED (αναβόσβημα για ζυγά, εναλλαγή για μονά).
        \item \texttt{APP\_STATE\_CONTINUOUS\_BLINK}: Ειδική κατάσταση που χρησιμοποιείται κατά το αναβόσβημα του LED για τα ζυγά ψηφία, διαχειριζόμενη τους κύκλους ON/OFF εντός του διαστήματος ανάλυσης του ψηφίου.
    \end{itemize}
    Η μετάβαση μεταξύ των καταστάσεων καθοδηγείται από τις εισόδους του χρήστη (UART, κουμπί) και τους χρονιστές.

    \item \textbf{Ουρά Εισόδου UART (UART Input Queue)}: Μια κυκλική ουρά (circular buffer) χρησιμοποιείται για την προσωρινή αποθήκευση των χαρακτήρων που λαμβάνονται από τη σειριακή θύρα UART. Η ISR λήψης UART προσθέτει τους εισερχόμενους χαρακτήρες στην ουρά, ενώ η κύρια λογική του προγράμματος τους αφαιρεί και τους επεξεργάζεται. Αυτό αποσυνδέει την ασύγχρονη λήψη δεδομένων από την επεξεργασία τους.

    \item \textbf{Global Flags}:
    \begin{itemize}
        \item \texttt{continuous\_mode\_active}: Υποδεικνύει εάν το σύστημα βρίσκεται σε συνεχή λειτουργία, επαναλαμβάνοντας την ανάλυση του τελευταίου αριθμού.
        \item \texttt{led\_current\_state\_on}: Αποθηκεύει την τρέχουσα λογική κατάσταση του LED (ON/OFF), ανεξάρτητα από το αν είναι παγωμένο.
        \item \texttt{led\_should\_blink}: Σημαία που υποδεικνύει ότι το LED πρέπει να βρίσκεται σε κατάσταση αναβοσβήματος (για ζυγά ψηφία).
        \item \texttt{led\_frozen}: Υποδεικνύει εάν η φυσική κατάσταση του LED είναι "παγωμένη" από το πάτημα του κουμπιού. Όταν είναι \texttt{true}, το LED δεν αλλάζει την εμφάνισή του.
        \item \texttt{uart\_char\_received\_flag}: (volatile boolean) Τίθεται από την UART ISR όταν ένας νέος χαρακτήρας τοποθετείται στην ουρά λήψης, σηματοδοτώντας στον κύριο βρόχο ότι υπάρχουν δεδομένα για επεξεργασία.
        \item \texttt{button\_pressed\_flag}: Τίθεται από την EXTI ISR όταν ανιχνευτεί πάτημα του κουμπιού, σηματοδοτώντας στην κύρια λογική να επεξεργαστεί την ενέργεια.
        \item \texttt{new\_input\_interrupt\_flag}: Τίθεται εάν ληφθεί νέα είσοδος UART ενώ βρίσκεται σε εξέλιξη η ανάλυση ενός αριθμού, επιτρέποντας τη διακοπή της τρέχουσας ανάλυσης.
    \end{itemize}
\end{itemize}

\subsection{Ροή Προγράμματος (Program Flow)}
Η ροή του προγράμματος είναι βασισμένη σε έναν ατέρμονα βρόχο (main loop) που συντονίζει τις λειτουργίες του συστήματος, αντιδρώντας σε γεγονότα που σηματοδοτούνται από τις ρουτίνες εξυπηρέτησης διακοπών (ISRs) μέσω καθολικών σημαιών.

\begin{enumerate}
    \item \textbf{Αρχικοποίηση}: Κατά την εκκίνηση, το σύστημα αρχικοποιεί τα περιφερειακά (GPIOs για LED και κουμπί, UART, SysTick timer, EXTI για το κουμπί) και τις καθολικές μεταβλητές, συμπεριλαμβανομένης της ουράς UART και των σημαιών. Η αρχική κατάσταση του συστήματος ορίζεται σε \texttt{APP\_STATE\_IDLE}.

    \item \textbf{Κύριος Βρόχος (Main Loop)}: Ο κύριος βρόχος εκτελείται συνεχώς και είναι υπεύθυνος για:
    \begin{itemize}
        \item \textbf{Έλεγχος Σημαιών Διακοπών}: Περιοδικά ελέγχει τις σημαίες που τίθενται από τις ISRs.

        \item \textbf{Επεξεργασία Εισόδου UART}: Όταν η σημαία \texttt{uart\_char\_received\_flag} είναι ενεργή:
        \begin{enumerate}
            \item Η ακολουθία χαρακτήρων διαβάζεται από την ουρά UART.
            \item Γίνεται έλεγχος για τον ειδικό χαρακτήρα '-' στο τέλος της ακολουθίας για την ενεργοποίηση της συνεχούς λειτουργίας (\texttt{continuous\_mode\_active}).
            \item Τα ψηφία εξάγονται και αποθηκεύονται για ανάλυση.
            \item Το σύστημα μεταβαίνει στην κατάσταση \texttt{APP\_STATE\_ANALYZING\_DIGIT} για να ξεκινήσει την επεξεργασία του πρώτου ψηφίου.
            \item Η σημαία \texttt{uart\_char\_received\_flag} καθαρίζεται.
        \end{enumerate}

        \item \textbf{Διαχείριση Πατήματος Κουμπιού}: Όταν η σημαία \texttt{button\_pressed\_flag} είναι ενεργή:
        \begin{enumerate}
            \item Η κατάσταση της σημαίας \texttt{led\_frozen} αντιστρέφεται.
            \item Καταγράφεται μέσω UART το πάτημα του κουμπιού και η νέα κατάσταση παγώματος του LED.
            \item Η φυσική κατάσταση του LED ενημερώνεται άμεσα: αν το \texttt{led\_frozen} είναι \texttt{true}, το LED παγώνει στην τρέχουσα οπτική του κατάσταση. Αν είναι \texttt{false}, το LED παίρνει την τιμή της \texttt{led\_current\_state\_on}.
            \item Η σημαία \texttt{button\_pressed\_flag} καθαρίζεται.
        \end{enumerate}

        \item \textbf{State Machine}: Η συμπεριφορά του συστήματος εξαρτάται από την τρέχουσα \texttt{AppState}:
        \begin{itemize}
            \item \texttt{APP\_STATE\_IDLE}: Το σύστημα αναμένει νέα είσοδο.
            \item \texttt{APP\_STATE\_ANALYZING\_DIGIT}:
                \begin{itemize}
                    \item Ένα ψηφίο κάθε φορά αναλύεται. Ο χρονιστής SysTick (μέσω λογισμικού χρονιστή) καθορίζει το διάστημα των 500ms για την ανάλυση κάθε ψηφίου.
                    \item Αν το ψηφίο είναι ζυγό: το LED τίθεται σε κατάσταση αναβοσβήματος (\texttt{APP\_STATE\_LED\_BLINKING}) για 200ms ON / 200ms OFF. Η λογική κατάσταση \texttt{led\_current\_state\_on} παραμένει αμετάβλητη.
                    \item Αν το ψηφίο είναι μονό: η λογική κατάσταση του LED (\texttt{led\_current\_state\_on}) αντιστρέφεται.
                    \item Η φυσική κατάσταση του LED ενημερώνεται (\texttt{leds\_set()}) μόνο αν \texttt{led\_frozen} είναι \texttt{false}.
                    \item Το αποτέλεσμα της ανάλυσης καταγράφεται μέσω UART.
                    \item Μετά την πάροδο των 500ms, το σύστημα προχωρά στο επόμενο ψηφίο ή, αν δεν υπάρχουν άλλα, μεταβαίνει σε \texttt{APP\_STATE\_IDLE} (ή \texttt{APP\_STATE\_CONTINUOUS\_WAIT} αν είναι ενεργοποιημένη η συνεχής λειτουργία).
                \end{itemize}
            \item \texttt{APP\_STATE\_LED\_BLINKING}: Ο λογισμικός χρονιστής που οδηγείται από το SysTick διαχειρίζεται το αναβόσβημα του LED. Μετά την ολοκλήρωση της περιόδου αναβοσβήματος για το τρέχον ζυγό ψηφίο (που συμπίπτει με τα 500ms της ανάλυσης του ψηφίου), το σύστημα επιστρέφει για να επεξεργαστεί το επόμενο ψηφίο ή να ολοκληρώσει την ανάλυση.
            \item \texttt{APP\_STATE\_CONTINUOUS\_WAIT}: Αν η συνεχής λειτουργία είναι ενεργή, μετά την ανάλυση όλων των ψηφίων, το σύστημα εισέρχεται σε μια σύντομη αναμονή (π.χ. 500ms) πριν ξεκινήσει εκ νέου την ανάλυση της ίδιας ακολουθίας ψηφίων.
        \end{itemize}
    \end{itemize}

    \item \textbf{Αλληλεπίδραση ISR - Main Loop}:
    \begin{itemize}
        \item Η \textbf{UART RX ISR} είναι υπεύθυνη για την ασύγχρονη λήψη χαρακτήρων και την τοποθέτησή τους στην ουρά εισόδου. Όταν ανιχνεύσει το τέλος μιας εισόδου (π.χ. χαρακτήρας newline), θέτει τη σημαία \texttt{uart\_char\_received\_flag}.
        \item Η \textbf{Button EXTI ISR} ανιχνεύει το πάτημα του κουμπιού, αυξάνει έναν μετρητή πατημάτων (προαιρετικά, για logging) και θέτει τη σημαία \texttt{button\_pressed\_flag}. Η ISR είναι σχεδιασμένη να είναι σύντομη για να μην καθυστερεί άλλες διακοπές.
        \item Η \textbf{SysTick ISR} εκτελείται περιοδικά (π.χ. κάθε 1ms) και ενημερώνει τους μετρητές των λογισμικών χρονιστών που χρησιμοποιούνται από την κύρια λογική για τον χρονισμό της ανάλυσης ψηφίων και του αναβοσβήματος του LED. Δεν θέτει άμεσα σημαίες για τον κύριο βρόχο, αλλά ο κύριος βρόχος ελέγχει τις τιμές αυτών των χρονιστών.
    \end{itemize}
\end{enumerate}

\section{Προκλήσεις & Λύσεις}
\label{sec:challenges}
Κατά την ανάπτυξη του συστήματος αντιμετωπίστηκαν ορισμένες προκλήσεις, οι οποίες επιλύθηκαν με συγκεκριμένες τεχνικές και προσαρμογές στον κώδικα:

\begin{itemize}
    \item \textbf{Timer Initialization Crash}:
    \begin{itemize}
        \item \textbf{Πρόκληση}: Το πρόγραμμα παρουσίαζε crash κατά την αρχικοποίηση του SysTick.
        \item \textbf{Λύση}: Η ανάλυση έδειξε ότι υπήρχε ένα race condition. Ο timer ξεκινούσε πριν η callback function οριστεί πλήρως, οδηγώντας σε NULL pointer dereference κατά το πρώτο interrupt του timer, παρ'όλο που δεν είχε γίνει enabled.
    \end{itemize}

    \item \textbf{Button Interrupts}:
    \begin{itemize}
        \item \textbf{Πρόκληση}: Η ανίχνευση του πατήματος του κουμπιού, που ήταν αρχικά ρυθμισμένη για πτώση ακμής (falling edge), ήταν αναξιόπιστη. Η ISR του EXTI περιέχει έναν έλεγχο της τρέχουσας κατάστασης του pin (\texttt{if(p->IDR & (1<<IRQ\_pin\_index))}), ο οποίος αποτύγχανε επειδή τη στιγμή του ελέγχου (μετά την πτώση της ακμής), το pin ήταν ήδη σε κατάσταση LOW.
        \item \textbf{Λύση}:
            \begin{enumerate}
                \item \textbf{Άμεση Αντιμετώπιση}: Η διακοπή ρυθμίστηκε να ενεργοποιείται με ανύψωση ακμής (rising edge), δεδομένου ότι το κουμπί συνδέεται με pull-up αντίσταση, οπότε το πάτημα δημιουργεί πτώση ακμής και το άφημα ανύψωση. Έτσι, η ενέργεια (πάγωμα/ξεπάγωμα LED) εκτελείται κατά το άφημα του κουμπιού. Αυτό παρέκαμψε το πρόβλημα του ελέγχου κατάστασης εντός της ISR.
            \end{enumerate}
    \end{itemize}
\end{itemize}

\section{Testing}
Για δοκιμή της ορθής λειτουργίας δοκιμάστηκαν διάφορες ακολουθίες εισόδου αριθμών, συμπεριλαμβανομένων κενών εισόδων, αριθμών με ζυγά και μονά ψηφία, την ενεργοποίηση και απενεργοποίηση της συνεχούς λειτουργίας, καθώς και την αλληλεπίδραση με το πάγωμα του LED μέσω του κουμπιού κατά τη διάρκεια της ανάλυσης.
\section{Source Code}
Github:
\href{https://github.com/charisvt/micro-lab2}{https://github.com/charisvt/micro-lab2}

\end{document}